2015/6/8 9:45 demo建立，led/定时器 ok 框架已经在青风的板子上运行
2015/6/9 14:12 iwdg已经起作用、halt状态已经起作用、外部中断唤醒halt状态已经起作用
D1(GPIOF.5)/D2(GPIOF.6)/D3(GPIOF.7)进入跑马灯状态。约5秒后进入停机状态。按键1(GPIOI.0)按键2(GPIOE.4)可以唤醒之，再次进入跑马灯状态。
2015/7/28 10:48 加入了串口功能，未验证(已验证.用杜邦线飞线接到P5的3脚). 修改action_t的定义
2015/7/29 17:34 定义LED1..12端口
2015/7/30 10:00 可以通过动作队列操作LED灯. 可通过动作队列操作开锁功能。
2015/7/31 17:55 确认LED1..12可用。flash操作初步建立
2015/8/3 15:29 i2c触摸部分数据发送成功(逻辑分析仪查看得到正确数据)
2015/8/4 17:00 上电处理分开.
2015/8/5 11:02 指纹传感器上电动作反应. iic总算是可以用了
2015/8/6 9:08 初步认可iic接口的MPR121按键有效. 语音问题：当前没有引出busy引脚，不能判断语音结束，不能拼接语音。(暂时以BEEP作为提示音) 按键序与LED序号对应完成
2015/8/7 9:01 将iic库文件stm8s_i2c.c/stm8s_i2c.h替换成"实验十三：i2c之24c02读写"的iic库同名文件, l_i2c_touch.c/l_i2c_touch.h文件作相应修改。可能通信。故障待深入分析. 目前认为可以不理会第一次上电第二次上电的问题。在idle状态视为同一种消息
2015/8/11 14:50 指纹头感应上电功能正常
2015/8/12 9:29 确认UART1有数据发出3A 00 00 00 00 00 3A 8B(用STC_ISP工具接收到115200N81), 波特率改成9600bps. 已确认指纹头可接收查询命令. 指纹开锁成功
2015/8/14 15:42 初步点亮oled
2015/8/18 16:46 可显示24x24点阵汉字
2015/8/21 12:05 已验证set可用并得到按键消息
2015/8/24 10:49 完成24x24汉字显示函数。重写16x16汉字显示函数. 16x16楷体显示不清晰，改为宋体. 已可显示完整的菜单界面
2015/8/26 18:13 改用GPIO模拟IIC，用逻辑分析仪从SDA/SCL上看到正确数据. 将stack由0x100改成0x200
2015/8/28 10:55 密码开锁显示界面. iic接口有反应, 按键功能有效
2015/9/2 15:10 录入密码的界面大概有了. 对内存使用进行了大幅调整，按键死机问题似有变化.
2015/9/6 17:15 语音可按序号发出声音。未完成多片段拼接
2015/9/9 16:50 可播放连续语音
2015/9/10 15:28 将只读的显示码内容移到0x18000的位置
2015/9/11 17:43 录入密码的过程及验证通过。修改了库文件stm8s_flash.c中的void FLASH_ProgramByte(uint32_t Address, uint8_t Data)函数。将*(PointerAttr uint8_t*) (uint16_t)Address = Data改成*(PointerAttr uint8_t*)Address = Data
 				验证psword_add()功能正常.
 				密码的录入、开锁功能正常
2015/9/14 18:14 录入指纹之前的语音、显示等
2015/9/16 16:38 管理员指纹的录入删除可正常工作
2015/9/18 10:14 密码删除操作等待验证. 密码边界问题已解决
2015/9/22 8:49  密码添加/删除时的id选择修改
2015/9/23 11:08 完成恢复出厂流程. 确认可删除指纹. 无指纹模板时，提示录入管理指纹
2015/9/24 14:37 进入菜单设置权限验证(验证管理指纹或录入第1管理指纹), 显示及语音已完成
2015/9/25 11:25 进入菜单设置权限验证完成。改正删除过程中的id号显示问题. 解决删除指纹的故障(系统功能栈溢出). 解决第一次上电不能录指纹的故障(分析后发现，前面几指纹录入/删除相关的故障都由功能栈溢出引起)
2015/10/8 16:40 可唤醒并进入操作流程
2015/10/9 17:02 arch.c文件中的消息队列及功能栈函数改名，用到的地方都相应的改名. oled复位中间使用循环等待
2015/10/10 13:54 上电显示/休眠唤醒端口初始化
2015/10/19 17:08 adc电压采集完成
2015/10/20 14:51 低电校验操作过程. 读取到adc值(要确认电路). ADC可用并读出正常(写入到flash并用ST-Tool读出数据正常)
2015/10/21 9:19 开锁完成后低电压报警. 重新实现语音控制，可用。语音索引与前面的实现少一个脉冲。低电报警显示. 实现容错密码比对函数，待验证. 菜单设置中，*号产生CMSG_BACK消息代替CMSG_INIT消息
2015/10/22 15:24 虚位密码功能的设置使用初步ok. 消除开锁完成后的异常BEEP. 在完成开锁方式中发现链接器不支持超过32KB的代码!!!
2015/10/23 11:04 代码超限问题解决。完成菜单开锁模式设置。完成开锁模式功能。已初步验证功能，显示及语音方面的问题待处理
2015/10/26 9:21 修改开锁模式功能。发现"指纹+指纹"方式故障(已解决：原因系f_finger状态处理CMSG_SECO消息时收到CMSG_TMR消息，进而执行了CMSG_INIT消息的动作). 目前的休眠时总电流5.3mA。
2015/10/27 17:24 添加唤醒时触摸配置(前面修改唤醒后的动作，导致没有正确配置mpr121引起唤醒后触摸无反应的故障)。
2015/10/28 11:47 添加版本显示. 添加格式化时间显示(未完成)
2015/10/29 8:58 确定时间芯片可正常运行(菜单中可查时间正常变化). 每条语音限定时间，而不以busy脚作为结束检测点
2015/10/30 9:46 w25q16进入powerDown模式halt后，整板电流降为3.7mA。仍需改善. w25q16已通过以下方式初步验证可行。
 		DeviceID = SPI_FLASH_ReadDeviceID();
  		FlashID = SPI_FLASH_ReadID();     
		SPI_FLASH_SectorErase(FLASH_SectorToErase);	 	 
		SPI_FLASH_BufferWrite(Tx_Buffer,0x00000, sizeof(Tx_Buffer));	
  		SPI_FLASH_BufferRead(Rx_Buffer,0x00000, sizeof(Rx_Buffer));
        OLED_ShowString8x16(0, 0, Rx_Buffer);
2015/11/4 14:07 新语音芯片顺序微调(测量显示0.1ms)
2015/11/5 15:31 测量显示0.1mA至更低(功耗问题可认为暂时解决)。但出现不明原因的电机转动(首先怀疑是静电)
2015/11/9 12:01 加入查故障代码找语音故障. 已查明原因：系清空语音队列时，没有清除相关的标记flag.2(与其它一些特性矛盾, 查看后发现也与flag的处理相关). 
		以动作队列的形式处理语音(包括要执行的函数及参数)。取队列后处理回调. 可以达到去耦效果
2015/11/10 10:24修正低电报警时的显示乱码(字符索引错.) 添加"无指纹恢复出厂(F+3+7)"功能.

2016/3/10 15:40 修改密码长度宏定义CPSWORDLEN(密码开锁失败故障psword_Query_00用到不合理的数值导致密码失败)。对MPSWORD_PUSH(x)处理作保护
2016/3/17 9:07 已经使JP100-A指纹传感器点亮。下一步完善JP100-A控制. 可以录入及删除全部指纹. 查询比对操作也成功过，需要调整对JP100-A返回结果的处理.
2016/3/23 14:43添加UART3编译通过
2016/3/25 10:50 调整对指纹传感器返回数据的处理。效果有改善，待进一步完善
2016/3/28 15:03 蓝牙界面基本上完成，下一步焊上模块验证。按键与LED指示一致
        目前了解到的恢复出厂流程：
        1.典雅锁：1+(5+F)(长嘀一声)+初始化密码
        2.行云锁：后按键+前按键1
        3.现代锁："F+*+#+F"退出，(中途不得进行开锁操作)"F+*+#+F"
        4.雷纹锁：按"设置"键持续5秒以上
        5.天防锁：同时按住后面板上的"A+B"5-10秒
        6.金指纹：???
        7.方程式：长按"设置"键持续5秒以上
        
        考虑新锁的恢复出厂流程：按"设置"键持续5秒，中途不得进行开锁操作，再按"设置"键持续5秒以上。
2016/3/30 10:14 在录入及比对之前，用0x0130命令对其初始化(退出录入比对等等工作状态). 整理按键状态变化top图,并以之为依据重新编码。长按set键恢复出厂ok。 录入过程可行，删除过程存在响应故障
2016/3/31 16:34 用户指纹删除成功(播放已清空语音)
2016/4/1 15:07 新发现的bluetooth电源控制引脚不能控制的故障已排除(系统休眠后将端口关闭，而Halt_OnDevice()没有打开)。
2016/4/5 16:12 uart3的收发已经ok, BT_GetRespData()小有改动并得到验证. 通过屏蔽chksum将收到的所有数据视为比对成功，可以运行到开锁。
2016/4/11 15:48 已实现手机APP蓝牙开锁功能
2016/4/12 13:17 添加Get_ChipID及bluetooth初始化相关的接口。初始确定时间写入可行, 设置中显示明显有错
2016/4/13 14:14 时间调节界面BCD码与HEX不一致的问题基本解决。解决时间设置暗显示时只显示0的故障。时间调整完成(另外对读出的数据清除高位)
2016/4/14 17:35 调整各端口扫描方式(指纹/设置键已修改完成，其它待实验验证)
2016/4/15 10:59 添加VOP按键唤醒。确认遥控可用(可在PeripheralInput_Check()选择发送消息的电平状态)。 (发现编号2的板子PB.1一直为低电平，换一块板后正常)再次确认各i/o端口检测位及有效电平。改下前面遥控异常检测电平(可以使用但与预期不符)。
2016/4/18 15:58 需要手机APP端重新连接，然后重新发送数据。
2016/4/28 15:55 修改UART1中断接收代码如下：
				} else if(SET == UART1_GetITStatus(UART1_IT_LBDF)) {	
				//} else if(SET == UART1_GetITStatus(UART1_IT_OR)) {
				另外添加对UART1_IT_OR/UART1_FLAG_OR的处理。与UART1_FLAG_RXNE/UART1_FLAG_RXNE的处理方式相同
2016/5/11 16:54 在2016/4/29的版本作基线, 作以下修改:
			1.语音的Busy有关代码去掉;
			2.休眠之前的CLK_PeripheralClockConfig(CLK_PERIPHERAL_AWU,DISABLE)注释掉
			3.添加sleep.c/sleep.h文件
			4.在main.c文件中添加awu的初始化代码，stm8s_interruput.c文件awu中断添加相关代码
			5.工程中添加awu/tim3驱动的库文件
			6.添加待机情景下蓝牙开锁功能
2016/5/12 9:22 通过在awu中断设置标志，唤醒事件检测中查此标志的方法判断是否真正唤醒。目前效果最好
			已经达到定时唤醒蓝牙开锁功能，效果还不理想。FP断电及OLED/LED显示界面
			缩小uart1/3完成标志与收到最后1byte时间60ms改为10ms。偶尔蓝牙接口不能连续开锁(退出后需要等待进入休眠，可能与待机休眠前的消息处理有关)
2016/5/13 20:20 开锁记录查询，指纹开锁记录的存贮(其它密码、蓝牙等几种开锁记录存贮待完成)
2016/5/16 17:54 更换时间显示函数(修改显示缓存后可正确显示)
2016/5/19 10:18 可查到一条记录了(以管理员/用户/密码/蓝牙ID的形式显示) 管理员/用户/密码开锁记录查询正常
2016/5/20 10:21 "指纹+密码"开锁、语音、显示正常。记录查询正常。指纹/密码，指纹+密码的开锁及记录查询均实现，并初步验证正常。
			解决恢复出厂显示残留部分上次字迹
			休眠(从指纹)唤醒区别处理，以提高响应速度(仍有改进的地方)